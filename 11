cat AUTO_CAN_NORMAL_SCRIPT.sql
set linesize 1000
set pagesize 10000
set heading off
set feedback off
set headsep on
set echo off
set colsep '    '
set wrap off
set verify off
set termout off
set trimspool on
SET SERVEROUTPUT ON
column spoolname new_value new_spoolname;
select concat(concat('/TFEEAPP/base_domain/Reports/Spool/AUTO_CAN',to_char(sysdate,'ddmmyyyy')),'.lst') spoolname from dual;
SPOOL &new_spoolname append;
alter session set nls_date_format='YYYYMMDD';
set SERVEROUTPUT on;
declare
cnt number;
CURSOR C1 IS
select
a.DUE_DT_CONTRACT,a.c_main_ref,a.c_func_short_name
from
fwco_master a,eximsys.std_holiday b
where a.C_TRX_STATUS='M'
and (a.BAL_FRGN_AMT > 0)
and a.C_LOCKED_FLAG='F'
and (a.CAN_FLG is null or a.CAN_FLG =0)
and to_date(sysdate,'YYYYMMDD')=to_date(a.due_dt_contract +3 ,'YYYYMMDD')
AND (a.AREA_DELIVERY != '3' OR DE_SUB_DT IS NOT NULL)
and TO_DATE((a.DUE_DT_CONTRACT),'YYYYMMDD')=to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD');
CURSOR C2 IS
select
a.BOOKING_DATE,a.AREA_DELIVERY,a.DE_SUB_DT,a.c_func_short_name,a.c_main_ref
from
fwco_master a,eximsys.std_holiday b
where a.C_TRX_STATUS='M'
and (a.BAL_FRGN_AMT > 0)
and a.C_LOCKED_FLAG='F'
and (a.CAN_FLG is null or a.CAN_FLG =0)
and to_date(sysdate,'YYYYMMDD')=to_date(a.BOOKING_DATE + 15 ,'YYYYMMDD')
and a.area_delivery = '3'
and a.DE_SUB_DT is null
and a.c_func_short_name <> 'SubmittedDE-15'
and a.booking_date=to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD');
cursor v1 (dt_abs date)is select to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD') as d_dt from eximsys.std_holiday b where to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD')  > to_date(TO_CHAR(dt_abs),'YYYYMMDD') and c_type='W'  order by to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD') ;
cursor v3 (dt_abs date)is SELECT to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD') as d_dt,c_type as holi_type from EXIMSYS.STD_HOLIDAY b where to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD')  > to_date(TO_CHAR(dt_abs),'YYYYMMDD') order by to_date(( B.C_YEAR||B.C_MONTH || B.C_DATE ),'YYYYMMDD');
begin
for C1_RECORD1 in C1
LOOP
cnt :=0;
for V2 in V1(c1_record1.due_dt_contract)
loop
cnt := D + 1;
dbms_output.put_line('C_MAIN_REF -- ' || c1_record1.c_main_ref  ||  'cnt -- ' || cnt);
if (CNT = 3) then
dbms_output.put_line( 'C_MAIN_REF -- ' || c1_record1.c_main_ref  || ' --d_dt-- ' || v2.d_dt);
update EXIMTRX.FWCO_MASTER set T_SYS_REL_TIME=V2.D_DT where C_MAIN_REF=C1_RECORD1.C_MAIN_REF ;
exit;
commit;
end if;
end loop;
end LOOP;
for C2_RECORD1 in C2
LOOP
cnt :=0;
for V4 in V3(C2_RECORD1.BOOKING_DATE)
LOOP
cnt := cnt + 1;
dbms_output.put_line('C_MAIN_REF -- ' || c2_record1.c_main_ref  ||  'cnt -- ' || cnt);
if (cnt = 16) then
dbms_output.put_line( 'C_MAIN_REF -- ' || c2_record1.c_main_ref  || ' --d_dt-- ' || v4.d_dt);
update EXIMTRX.FWCO_MASTER set T_SYS_REL_TIME=v4.d_dt where C_MAIN_REF=C2_RECORD1.C_MAIN_REF ;
for v11 in v1(v4.d_dt)
loop
dbms_output.put_line( 'C_MAIN_REF -- ' || c2_record1.c_main_ref  || ' --d_dt-- ' || v11.d_dt);
exit;
update EXIMTRX.FWCO_MASTER set T_SYS_REL_TIME=v11.d_dt where C_MAIN_REF=C2_RECORD1.C_MAIN_REF ;
commit;
end loop;
end if;
end loop;
end loop;
update eximtrx.fwco_master set can_flg='1',rec_type='5' where t_sys_rel_time=trunc(sysdate) and (c_main_ref like '%FS%' or c_main_ref like '%FP%');






Got it, Boss. If you want to run this manually inside SQL*Plus / SQLcl / SQL Developer, here’s a clean, step-by-step version (with a few fixes). I’ve removed the shell/spool bits and corrected a couple of bugs:
	•	cnt := D + 1; → should be cnt := cnt + 1;
	•	exit; commit; → the commit after exit never runs; we’ll commit at the end (or you can commit per row if you prefer).
	•	Replaced awkward to_date(sysdate,'YYYYMMDD') and to_date(date,'YYYYMMDD') with trunc(...) date logic.
	•	Kept your holiday table logic but made joins clearer.

⸻

1) (Optional) Show which rows will be affected — preview

-- See candidates for C1 logic
select a.c_main_ref, a.due_dt_contract, a.c_func_short_name
from fwco_master a
join eximsys.std_holiday b
  on trunc(a.due_dt_contract) = to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD')
where a.c_trx_status = 'M'
  and a.bal_frgn_amt > 0
  and a.c_locked_flag = 'F'
  and (a.can_flg is null or a.can_flg = 0)
  and trunc(sysdate) = trunc(a.due_dt_contract) + 3
  and (a.area_delivery != '3' or a.de_sub_dt is not null);

-- See candidates for C2 logic
select a.c_main_ref, a.booking_date, a.area_delivery, a.de_sub_dt, a.c_func_short_name
from fwco_master a
join eximsys.std_holiday b
  on trunc(a.booking_date) = to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD')
where a.c_trx_status = 'M'
  and a.bal_frgn_amt > 0
  and a.c_locked_flag = 'F'
  and (a.can_flg is null or a.can_flg = 0)
  and trunc(sysdate) = trunc(a.booking_date) + 15
  and a.area_delivery = '3'
  and a.de_sub_dt is null
  and a.c_func_short_name <> 'SubmittedDE-15';

If these look OK, proceed.

⸻

2) Enable output and date format (just for your session)
set serveroutput on size unlimited
alter session set nls_date_format = 'YYYY-MM-DD';


⸻

3) Run the PL/SQL block (fixed & manual-friendly)

This reproduces your logic:
	•	For each C1 row: find the 3rd future working day (c_type = 'W') after due_dt_contract, set t_sys_rel_time to that date.
	•	For each C2 row: find the 16th future holiday-calendar date (any c_type) after booking_date, set t_sys_rel_time to that; then advance to the next working day and set it again.
	•	Finally: set can_flg='1' & rec_type='5' for today’s t_sys_rel_time on refs like %FS% or %FP%.
declare
  cnt number;

  cursor c1 is
    select a.due_dt_contract, a.c_main_ref, a.c_func_short_name
    from fwco_master a
    join eximsys.std_holiday b
      on trunc(a.due_dt_contract) = to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD')
    where a.c_trx_status = 'M'
      and a.bal_frgn_amt > 0
      and a.c_locked_flag = 'F'
      and (a.can_flg is null or a.can_flg = 0)
      and trunc(sysdate) = trunc(a.due_dt_contract) + 3
      and (a.area_delivery != '3' or a.de_sub_dt is not null);

  cursor c2 is
    select a.booking_date, a.area_delivery, a.de_sub_dt, a.c_func_short_name, a.c_main_ref
    from fwco_master a
    join eximsys.std_holiday b
      on trunc(a.booking_date) = to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD')
    where a.c_trx_status = 'M'
      and a.bal_frgn_amt > 0
      and a.c_locked_flag = 'F'
      and (a.can_flg is null or a.can_flg = 0)
      and trunc(sysdate) = trunc(a.booking_date) + 15
      and a.area_delivery = '3'
      and a.de_sub_dt is null
      and a.c_func_short_name <> 'SubmittedDE-15';

  -- Next working days after a given date
  cursor v1 (dt_abs date) is
    select to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD') as d_dt
    from eximsys.std_holiday b
    where to_date(b.c_year||b.c_month||b.c_date,'YYYYMMDD') > trunc(dt_abs)
      and b.c_type = 'W'
    order by to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD');

  -- Next holiday-calendar dates (any type) after a given date
  cursor v3 (dt_abs date) is
    select to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD') as d_dt, b.c_type as holi_type
    from eximsys.std_holiday b
    where to_date(b.c_year||b.c_month||b.c_date,'YYYYMMDD') > trunc(dt_abs)
    order by to_date(b.c_year||b.c_month||b.c_date, 'YYYYMMDD');
begin
  -- C1 logic: 3rd future working day after due_dt_contract
  for r in c1 loop
    cnt := 0;
    for h in v1(r.due_dt_contract) loop
      cnt := cnt + 1;
      dbms_output.put_line('C1 | '||r.c_main_ref||' | step '||cnt);
      if cnt = 3 then
        update eximtrx.fwco_master
           set t_sys_rel_time = h.d_dt
         where c_main_ref = r.c_main_ref;
        dbms_output.put_line('C1 | '||r.c_main_ref||' | t_sys_rel_time -> '||to_char(h.d_dt,'YYYY-MM-DD'));
        exit; -- done for this ref
      end if;
    end loop;
  end loop;

  -- C2 logic: 16th future calendar day, then next working day after that
  for r in c2 loop
    cnt := 0;
    for h in v3(r.booking_date) loop
      cnt := cnt + 1;
      dbms_output.put_line('C2 | '||r.c_main_ref||' | step '||cnt||' ('||h.holi_type||')');
      if cnt = 16 then
        -- first set to the 16th calendar day
        update eximtrx.fwco_master
           set t_sys_rel_time = h.d_dt
         where c_main_ref = r.c_main_ref;
        dbms_output.put_line('C2 | '||r.c_main_ref||' | t_sys_rel_time -> '||to_char(h.d_dt,'YYYY-MM-DD'));

        -- then advance to the very next working day after that
        for h2 in v1(h.d_dt) loop
          update eximtrx.fwco_master
             set t_sys_rel_time = h2.d_dt
           where c_main_ref = r.c_main_ref;
          dbms_output.put_line('C2 | '||r.c_main_ref||' | t_sys_rel_time(next W) -> '||to_char(h2.d_dt,'YYYY-MM-DD'));
          exit; -- only the immediate next working day
        end loop;

        exit; -- done with v3 for this ref
      end if;
    end loop;
  end loop;

  -- Final flag update for today's releases
  update eximtrx.fwco_master
     set can_flg = '1',
         rec_type = '5'
   where trunc(t_sys_rel_time) = trunc(sysdate)
     and (c_main_ref like '%FS%' or c_main_ref like '%FP%');

  commit;
  dbms_output.put_line('DONE. Committed changes.');
exception
  when others then
    dbms_output.put_line('ERROR: '||sqlerrm);
    rollback;
    dbms_output.put_line('Rolled back.');
end;
/


4) Verify results
-- Check today’s releases now flagged
select c_main_ref, t_sys_rel_time, can_flg, rec_type
from eximtrx.fwco_master
where trunc(t_sys_rel_time) = trunc(sysdate)
  and (c_main_ref like '%FS%' or c_main_ref like '%FP%');

-- Spot-check some updated refs
select c_main_ref, t_sys_rel_time
from eximtrx.fwco_master
where t_sys_rel_time >= trunc(sysdate) - 1
order by t_sys_rel_time desc
fetch first 50 rows only;


Notes / assumptions
	•	EXIMSYS.STD_HOLIDAY uses C_YEAR, C_MONTH, C_DATE (strings/numbers) and C_TYPE where 'W' means working day. If your codes differ, adjust C_TYPE filter.
	•	I used trunc(...) consistently to compare whole dates.
	•	If you prefer committing row-by-row, move the commit; inside the IF blocks (after each update), but it’s usually better to commit once.
	•	Run as a user with UPDATE rights on EXIMTRX.FWCO_MASTER.

If you want, I can also give you a version that only prints what would be updated (no actual updates) for a dry-run.


-- Upsert 10-Oct-2025 into holiday table as a working day ('W')
merge into eximsys.std_holiday b
using (
  select to_char(trunc(sysdate)-3,'YYYY') as y,
         to_char(trunc(sysdate)-3,'MM')   as m,
         to_char(trunc(sysdate)-3,'DD')   as d
  from dual
) s
on (b.c_year = s.y and b.c_month = s.m and b.c_date = s.d)
when not matched then
  insert (c_year, c_month, c_date, c_type)
  values (s.y, s.m, s.d, 'W');

commit;
